# Retail ETL Project - dbt Documentation

## üìä Vue d'ensemble du projet

Ce projet dbt transforme les donn√©es brutes de vente retail en mod√®le dimensionnel optimis√© pour l'analyse et le reporting. L'architecture suit les bonnes pratiques de mod√©lisation en √©toile avec s√©paration staging/transform.

## üèóÔ∏è Architecture des donn√©es

```
Sources (BigQuery)
    ‚Üì
[Staging Layer] (Views)
    ‚Üì
[Transform Layer] (Tables)
    ‚îú‚îÄ‚îÄ dim_customer (Dimension clients)
    ‚îú‚îÄ‚îÄ dim_product (Dimension produits)
    ‚îú‚îÄ‚îÄ dim_datetime (Dimension temporelle)
    ‚îî‚îÄ‚îÄ fct_invoices (Faits de vente)
    ‚Üì
[Snapshots] (Historique SCD Type 2)
    ‚îú‚îÄ‚îÄ snap_dim_customer
    ‚îú‚îÄ‚îÄ snap_dim_product
    ‚îî‚îÄ‚îÄ snap_raw_invoice
```

## üìã Mod√®les disponibles

### üéØ Tables de faits
- **`fct_invoices`** : Transactions de vente avec m√©triques calcul√©es

### üìê Tables de dimensions
- **`dim_customer`** : Clients uniques par pays avec codes ISO
- **`dim_product`** : Produits avec gestion des variations de prix
- **`dim_datetime`** : Dimension temporelle avec composants date/heure

### üì∏ Snapshots (SCD Type 2)
- **`snap_dim_customer`** : Historique des changements clients
- **`snap_dim_product`** : Historique des changements produits
- **`snap_raw_invoice`** : Historique des donn√©es sources

## üöÄ API FastAPI - Endpoints disponibles

| Endpoint | Description | Commande √©quivalente |
|----------|-------------|---------------------|
| `GET /run` | Ex√©cuter les mod√®les | `dbt run` |
| `GET /test` | Lancer les tests | `dbt test` |
| `GET /snapshot` | Capturer les snapshots | `dbt snapshot` |
| `GET /full-pipeline` | Pipeline complet | `dbt run && dbt snapshot && dbt test` |
| `GET /docs/generate` | G√©n√©rer documentation | `dbt docs generate` |
| `GET /docs/serve` | Servir documentation | `dbt docs serve` |

### D√©marrage de l'API
```bash
cd dbt-etl
python main.py
# API disponible sur http://localhost:8000
```

---

# Tests de Granularit√© DBT

## Vue d'ensemble

Ce projet contient des tests pour v√©rifier la granularit√© et l'int√©grit√© des tables de dimension et de fait.

## Types de tests impl√©ment√©s

### 1. Tests de sch√©ma (schema.yml)
- **Unicit√©** : V√©rifie que les cl√©s primaires sont uniques
- **Non-null** : V√©rifie que les colonnes critiques ne sont pas nulles
- **Valeurs accept√©es** : V√©rifie que les valeurs sont dans des plages valides
- **Int√©grit√© r√©f√©rentielle** : V√©rifie que les cl√©s √©trang√®res existent dans les tables de r√©f√©rence

### 2. Tests personnalis√©s (dossier tests/)
- **test_dim_customer_granularite.sql** : V√©rifie l'unicit√© par pays
- **test_dim_datetime_granularite.sql** : V√©rifie l'unicit√© par datetime_id
- **test_dim_product_granularite.sql** : V√©rifie l'unicit√© par combinaison stock_code + description + price
- **test_referential_integrity.sql** : V√©rifie l'int√©grit√© des cl√©s √©trang√®res

## Comment ex√©cuter les tests

### Tous les tests
```bash
dbt test
```

### Tests d'un mod√®le sp√©cifique
```bash
dbt test --models dim_customer
dbt test --models dim_datetime
dbt test --models dim_product
dbt test --models fct_invoices
```

### Tests personnalis√©s uniquement
```bash
dbt test --models test_type:generic
```

### Tests de sch√©ma uniquement
```bash
dbt test --models test_type:schema
```

### Ex√©cuter avec mode verbose pour plus de d√©tails
```bash
dbt test --verbose
```

## Granularit√© attendue

### dim_customer
- **Cl√© primaire** : `customer_id` (surrogate key de CustomerID + Country)
- **Granularit√©** : Un enregistrement par combinaison unique de client et pays

### dim_datetime
- **Cl√© primaire** : `datetime_id` (datetime original)
- **Granularit√©** : Un enregistrement par datetime unique

### dim_product
- **Cl√© primaire** : `product_id` (surrogate key de StockCode + Description + UnitPrice)
- **Granularit√©** : Un enregistrement par combinaison unique de produit et prix

### fct_invoices
- **Cl√© primaire** : `invoice_id`
- **Granularit√©** : Un enregistrement par ligne de facture

## R√©solution des √©checs de tests

Si un test √©choue :

1. **Unicit√©** : V√©rifiez s'il y a des doublons dans vos donn√©es sources
2. **Non-null** : V√©rifiez s'il y a des valeurs manquantes
3. **Int√©grit√© r√©f√©rentielle** : V√©rifiez si toutes les cl√©s √©trang√®res ont des correspondances

### D√©boguer un test sp√©cifique
```bash
# Compile le test sans l'ex√©cuter pour voir la requ√™te SQL
dbt compile --models test_dim_customer_granularite

# Ex√©cuter le test en mode debug
dbt test --models test_dim_customer_granularite --verbose
```


# Guide des Snapshots dbt - Retail ETL Project

## Vue d'ensemble

### Les snapshots dbt permettent de capturer l'√©volution historique des donn√©es en impl√©mentant une logique SCD Type 2 (Slowly Changing Dimensions de type 2).

## Snapshots disponibles

### 1. `snap_dim_customer`
- **Table source** : `dim_customer`
- **Strat√©gie** : `timestamp` 
- **Cl√© unique** : `customer_id`
- **Colonne de tracking** : `updated_at`

### 2. `snap_dim_product`
- **Table source** : `dim_product`
- **Strat√©gie** : `check`
- **Cl√© unique** : `product_id`
- **Colonnes surveill√©es** : `stock_code`, `description`, `price`

### 3. `snap_raw_invoice`
- **Table source** : `raw_invoice`
- **Strat√©gie** : `timestamp`
- **Cl√© unique** : `InvoiceNo + StockCode`
- **Colonne de tracking** : `snapshot_timestamp`

## Strat√©gies de d√©tection des changements

### Strategy: `timestamp`
- Utilise une colonne timestamp pour d√©tecter les changements
- Plus efficace pour les grandes tables
- N√©cessite une colonne `updated_at` fiable

### Strategy: `check`
- Compare les valeurs de colonnes sp√©cifiques
- Plus pr√©cis mais plus co√ªteux en calcul
- Id√©al quand pas de colonne timestamp disponible

## Commandes principales

### Ex√©cuter tous les snapshots
```bash
dbt snapshot
```

### Ex√©cuter un snapshot sp√©cifique
```bash
dbt snapshot --models snap_dim_customer
dbt snapshot --models snap_dim_product
dbt snapshot --models snap_raw_invoice
```

### Ex√©cuter avec s√©lection
```bash
# Tous les snapshots qui commencent par "snap_dim"
dbt snapshot --models snap_dim*

# Snapshots d'un tag sp√©cifique
dbt snapshot --models tag:daily
```

## Structure des tables snapshot

Chaque table snapshot contient les colonnes originales plus :

- `dbt_scd_id` : Identifiant unique du snapshot
- `dbt_updated_at` : Timestamp de la derni√®re mise √† jour
- `dbt_valid_from` : Date de d√©but de validit√©
- `dbt_valid_to` : Date de fin de validit√© (NULL = actuel)

## Exemple d'usage

### Interroger l'√©tat actuel
```sql
SELECT *
FROM {{ ref('snap_dim_customer') }}
WHERE dbt_valid_to IS NULL
```

### Voir l'historique d'un client
```sql
SELECT 
    customer_id,
    country,
    dbt_valid_from,
    dbt_valid_to
FROM {{ ref('snap_dim_customer') }}
WHERE customer_id = 'specific_customer_id'
ORDER BY dbt_valid_from
```

### Voir les changements sur une p√©riode
```sql
SELECT *
FROM {{ ref('snap_dim_product') }}
WHERE dbt_valid_from >= '2024-01-01'
  AND dbt_valid_from < '2024-02-01'
```

## Bonnes pratiques

### 1. Fr√©quence d'ex√©cution
- **Quotidienne** : Pour la plupart des dimensions
- **Horaire** : Pour les donn√©es critiques √† haute fr√©quence
- **Hebdomadaire** : Pour les donn√©es de r√©f√©rence stables

### 2. Gestion de l'espace
```sql
-- Archiver les anciens snapshots (> 2 ans)
DELETE FROM snapshots.snap_dim_customer
WHERE dbt_valid_to < DATE_SUB(CURRENT_DATE(), INTERVAL 2 YEAR)
```

### 3. Monitoring
- Surveiller la taille des tables snapshots
- Alerter en cas d'absence de nouveaux snapshots
- V√©rifier la coh√©rence des `dbt_valid_from/to`

## Tests recommand√©s

### Test d'unicit√© sur l'√©tat actuel
```sql
-- tests/test_snapshot_current_uniqueness.sql
SELECT 
    customer_id,
    COUNT(*) as nb_records
FROM {{ ref('snap_dim_customer') }}
WHERE dbt_valid_to IS NULL
GROUP BY customer_id
HAVING COUNT(*) > 1
```

### Test de continuit√© temporelle
```sql
-- tests/test_snapshot_temporal_continuity.sql
WITH gaps AS (
    SELECT 
        customer_id,
        dbt_valid_to,
        LEAD(dbt_valid_from) OVER (PARTITION BY customer_id ORDER BY dbt_valid_from) as next_valid_from
    FROM {{ ref('snap_dim_customer') }}
    WHERE dbt_valid_to IS NOT NULL
)
SELECT *
FROM gaps
WHERE dbt_valid_to != next_valid_from
```

## Int√©gration CI/CD

### Dans workflow.yaml
```yaml
- name: Run snapshots
  run: dbt snapshot
  
- name: Test snapshots
  run: dbt test --models snapshots
```

### Scheduling optimal
- **Snapshots** : Apr√®s `dbt run` mais avant `dbt test`
- **Ordre** : `run` ‚Üí `snapshot` ‚Üí `test`